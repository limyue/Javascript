<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>变量</title>
</head>
<body>
	<pre style="font-size: 24px">
		4.函数function
		包裹在{}代码块
		function myFunction()
		{
		这里是要执行的代码
		}
		
		var x =10000;
		function myFunction(var1,var2)
		{
		var a = 10;
		return a;
		output(x)
		}

		调用函数：
		myFunction()
		myFunction(var1,var2)
-------------------------------------------------------------------
		//递归函数
		function foo(i) {
		  if (i < 0)
		    return;
		  console.log('begin:' + i);
		  foo(i - 1);
		  console.log('end:' + i);
		}
		foo(3);
-----------------------------------------------------------------
		//嵌套函数
		function addSquares(a,b) {
		  function square(x) {	//平方运算
		    return x * x;
		  }
		  return square(a) + square(b);//a平方+b平方
		}
		a = addSquares(2,3); // 返回 13
		console.log(a)
--------------------------------------------------------------------		
	//闭包：可以调用外部函数并为外部函数和内部函数指定参数
		function outside(x) {
		  function inside(y) {
		    return x + y;
		  }
		  return inside;
		}

		fn_inside = outside(3); // 分步骤依次传入x=3
		result = fn_inside(5);//y=5	 最终结果3+5=8
		console.log(result)

		result1 = outside(3)(5); // 直接传值 x=3 y=5
		console.log(result1)	
		<hr>
		<h4>es6新特性</h4>
//es5默认参数
function multiply(a, b) {
  b = typeof b !== 'undefined' ?  b : 1;

  return a*b;
}

multiply(5); // 5
//es6可添加默认参数
function multiply(a, b = 1) {
  return a*b;
}

multiply(5); // 5

---------------------------------------------------------------------
//es6箭头函数
var a = [
  "Hydrogen",
  "Helium",
  "Lithium",
  "Beryllium"
];
//es5
var a2 = a.map(function(s){ return s.length });
console.log(a2); // logs [ 8, 6, 7, 9 ]
//es6
var a3 = a.map( s => s.length );
console.log(a3); // logs [ 8, 6, 7, 9 ]
----------------------------------------------------------------------
//this :箭头函数出现之前，每一个新函数都重新定义了自己的 this 值
//通过把 this 的值赋值给一个变量可以修复这个问题
function Person() {
  var self = this; 
  self.age = 0;
//es5
  setInterval(function growUp() {
    self.age++;
  }, 1000);
}
//箭头功能捕捉闭包上下文的 this 值，所以下面的代码工作正常
function Person(){
  this.age = 0;
//es6
  setInterval(() => {
    this.age++; 
  }, 1000);
}
		
	</pre>
	<script>
//es5默认参数
function multiply(a, b) {
  b = typeof b !== 'undefined' ?  b : 1;

  return a*b;
}

multiply(5); // 5
//es6可添加默认参数
function multiply(a, b = 1) {
  return a*b;
}

multiply(5); // 5


//es6箭头函数
var a = [
  "Hydrogen",
  "Helium",
  "Lithium",
  "Beryllium"
];
//es5
var a2 = a.map(function(s){ return s.length });
console.log(a2); // logs [ 8, 6, 7, 9 ]
//es6
var a3 = a.map( s => s.length );
console.log(a3); // logs [ 8, 6, 7, 9 ]

//this :箭头函数出现之前，每一个新函数都重新定义了自己的 this 值
//通过把 this 的值赋值给一个变量可以修复这个问题
function Person() {
  var self = this; 
  self.age = 0;
//es5
  setInterval(function growUp() {
    self.age++;
  }, 1000);
}
//箭头功能捕捉闭包上下文的 this 值，所以下面的代码工作正常
function Person(){
  this.age = 0;
//es6
  setInterval(() => {
    this.age++; 
  }, 1000);
}




		// x =10000;
		// function myFunction()
		// {
		// var a = 10;
		// return a;
		// //output(x);
		// //未输出（全局变量不是用output可以输出吗？）
		// }

		// document.write(myFunction())

		//递归函数
		// function foo(i) {
		//   if (i < 0)
		//     return;
		//   console.log('begin:' + i);
		//   foo(i - 1);
		//   console.log('end:' + i);
		// }
		// foo(3);

		//嵌套函数
		// function addSquares(a,b) {
		//   function square(x) {	//平方运算
		//     return x * x;
		//   }
		//   return square(a) + square(b);//a平方+b平方
		// }
		// a = addSquares(2,3); // 返回 13
		// console.log(a)

		//闭包：可以调用外部函数并为外部函数和内部函数指定参数
		function outside(x) {
		  function inside(y) {
		    return x + y;
		  }
		  return inside;
		}

		fn_inside = outside(3); // 分步骤依次传入x=3
		result = fn_inside(5);//y=5	 最终结果3+5=8
		console.log(result)

		result1 = outside(3)(5); // 直接传值 x=3 y=5
		console.log(result1)

	</script>

</body>
</html>